<!--
/*
 * Copyright 2017 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.ar.js - Spawn At Camera</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no,
  minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      font-family: monospace;
      margin: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100vh;
      -webkit-user-select: none;
      user-select: none;
    }
    #info {
      position: absolute;
      left: 50%;
      bottom: 0;
      transform: translate(-50%, 0);
      margin: 1em;
      z-index: 10;
      display: block;
      line-height: 2em;
      text-align: center;
    }
    #info * {
      color: #fff;
    }
    .title {
      background-color: rgba(40, 40, 40, 0.4);
      padding: 0.4em 0.6em;
      border-radius: 0.1em;
    }
    .links {
      background-color: rgba(40, 40, 40, 0.6);
      padding: 0.4em 0.6em;
      border-radius: 0.1em;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
    <div id="info">
      <span class="title">Geographically Situated Augmented Reality Models</span><br/>
      <span class="title">
          <input id="posSliderX" type="range" max=10 min=-10 value=0 step=0.1 onchange="changePosition('X')"/>
          <input id="posSliderY" type="range" max=10 min=-10 value=0 step=0.1 onchange="changePosition('Y')"/>
          <input id="posSliderZ" type="range" max=10 min=-10 value=0 step=0.1 onchange="changePosition('Z')"/>
          <br />
          <button onclick="removeBlueLines()">Remove Lines</button>
          Sensitivity: <input id="sensitivity" type="range" max=10 min=0 value=1 step=0.1 />
      </span>
    </div>
    <script src="../third_party/three.js/three.js"></script>
    <script src="../third_party/three.js/VRControls.js"></script>
    <script src="../dist/three.ar.js"></script>
    <script src="javascripts/GLTFLoader.js"></script>
    <script>

    var vrDisplay;
    var vrFrameData;
    var vrControls;
    var arView;

    var canvas;
    var camera;
    var scene;
    var renderer;
    var cube;

    var colors = [
      new THREE.Color( 0xffffff ),
      new THREE.Color( 0xffff00 ),
      new THREE.Color( 0xff00ff ),
      new THREE.Color( 0xff0000 ),
      new THREE.Color( 0x00ffff ),
      new THREE.Color( 0x00ff00 ),
      new THREE.Color( 0x0000ff ),
      new THREE.Color( 0x000000 )
    ];

    /**
     * Use the `getARDisplay()` utility to leverage the WebVR API
     * to see if there are any AR-capable WebVR VRDisplays. Returns
     * a valid display if found. Otherwise, display the unsupported
     * browser message.
     */
    THREE.ARUtils.getARDisplay().then(function (display) {
      if (display) {
        vrFrameData = new VRFrameData();
        vrDisplay = display;
        init();
      } else {
        THREE.ARUtils.displayUnsupportedMessage();
      }
    });

    function init() {
      // Turn on the debugging panel
      var arDebug = new THREE.ARDebug(vrDisplay);
      document.body.appendChild(arDebug.getElement());

      // Setup the three.js rendering environment
      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      console.log('setRenderer size', window.innerWidth, window.innerHeight);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.autoClear = false;
      canvas = renderer.domElement;
      document.body.appendChild(canvas);
      scene = new THREE.Scene();

      // Creating the ARView, which is the object that handles
      // the rendering of the camera stream behind the three.js
      // scene
      arView = new THREE.ARView(vrDisplay, renderer);

      // The ARPerspectiveCamera is very similar to THREE.PerspectiveCamera,
      // except when using an AR-capable browser, the camera uses
      // the projection matrix provided from the device, so that the
      // perspective camera's depth planes and field of view matches
      // the physical camera on the device.
      camera = new THREE.ARPerspectiveCamera(
        vrDisplay,
        60,
        window.innerWidth / window.innerHeight,
        vrDisplay.depthNear,
        vrDisplay.depthFar
      );

      // VRControls is a utility from three.js that applies the device's
      // orientation/position to the perspective camera, keeping our
      // real world and virtual world in sync.
      vrControls = new THREE.VRControls(camera);

      // Create the cube geometry that we'll copy and place in the
      // scene when the user clicks the screen
      var geometry = new THREE.BoxGeometry( 1, 1, 1 );
      var faceIndices = ['a', 'b', 'c'];
      for (var i = 0; i < geometry.faces.length; i++) {
        var f  = geometry.faces[i];
        for (var j = 0; j < 3; j++) {
          var vertexIndex = f[faceIndices[ j ]];
          f.vertexColors[j] = colors[vertexIndex];
        }
      }
      var material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });
      cube = new THREE.Mesh(geometry, material);

      // Bind our event handlers
      window.addEventListener('resize', onWindowResize, false);

      // Kick off the render loop!
      update();
    }

    /**
     * The render loop, called once per frame. Handles updating
     * our scene and rendering.
     */
    function update() {
      // Clears color from the frame before rendering the camera (arView) or scene.
      renderer.clearColor();

      // Render the device's camera stream on screen first of all.
      // It allows to get the right pose synchronized with the right frame.
      arView.render();

      // Update our camera projection matrix in the event that
      // the near or far planes have updated
      camera.updateProjectionMatrix();

      // From the WebVR API, populate `vrFrameData` with
      // updated information for the frame
      vrDisplay.getFrameData(vrFrameData);

      // Update our perspective camera's positioning
      vrControls.update();

      // Render our three.js virtual scene
      renderer.clearDepth();
      renderer.render(scene, camera);

      // Kick off the requestAnimationFrame to call this function
      // when a new VRDisplay frame is rendered
      vrDisplay.requestAnimationFrame(update);
    }

    /**
     * On window resize, update the perspective camera's aspect ratio,
     * and call `updateProjectionMatrix` so that we can get the latest
     * projection matrix provided from the device
     */
    function onWindowResize () {
      console.log('setRenderer size', window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }



    // + ========================= +
    // |     Placing Models        |
    // + ========================= +
    var modelLocations;
    var userOffset;
    var loader = new THREE.GLTFLoader();

    function placeModels() {
        if (!modelLocations) { return console.debug("Haven't gotten model locations yet"); }

        for (let i=0; i<modelLocations.length; i++) {
            // Create model
            let model = modelLocations[i].model;
            if (model) {
                console.debug('models/'+model);
                loader.load('models/'+model, function(gltf) {
                    gltf['modelName'] = model;
                    scene.add(gltf.scene);
                    // Place Cube
                    let loc = convert(modelLocations[i].latitude, modelLocations[i].longitude, modelLocations[i].elevation);
                    let loc_rel = {
                        x: loc.x - userOffset.x,
                        y: loc.y - userOffset.y,
                        z: loc.z - userOffset.z
                    }
                    scene.children[scene.children.length-1].position.set(loc_rel.x, loc_rel.y, loc_rel.z);
                    //clone.position.copy(pos);
                    //clone.quaternion.copy(ori);

                    console.debug("Set", modelLocations[i].model, "at", loc_rel);

                    // // Get Texture
                    // let texture = new THREE.TextureLoader().load( 'textures/'+model.replace(".gltf", "").replace(".glb", "")+'.jpg' );
                    // // immediately use the texture for material creation
                    // let material = new THREE.MeshBasicMaterial( { map: texture } );
                    // gltf.material

                    // draw a line to the models
                    var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
                    var geometry = new THREE.Geometry();
                    geometry.vertices.push(new THREE.Vector3( loc_rel.x, loc_rel.y, loc_rel.z) ); // object
                    geometry.vertices.push(new THREE.Vector3( 0, 0, 0) ); // camera
                    var line = new THREE.Line( geometry, material );
                    scene.add( line );
                    renderer.render( scene, camera );


                }, undefined, function(error) {
                    console.error(error);
                });
            }
            else {
                let clone = cube.clone();
                scene.add( clone );
                // Place Cube
                let loc = convert(modelLocations[i].latitude, modelLocations[i].longitude, modelLocations[i].elevation);
                let loc_rel = {
                    x: loc.x - userOffset.x,
                    y: loc.y - userOffset.y,
                    z: loc.z - userOffset.z
                }
                scene.children[scene.children.length-1].position.set(loc_rel.x, loc_rel.y, loc_rel.z);
                //clone.position.copy(pos);
                //clone.quaternion.copy(ori);


                console.debug("Set object at", loc_rel);
            }
        }
    }

    // + ======================== +
    // |           GPS            |
    // + ======================== +
    var gpsInc = 0;
    var gpsAvgs = {lat: 0, long: 0};

    function getLocation() {
        if (navigator.geolocation) {
            for (let i=0; i<10; i++) {
                navigator.geolocation.getCurrentPosition(showLocation)
            }
        }
    }

    function showLocation(position) {
        gpsAvgs.lat += position.coords.latitude;
        gpsAvgs.long += position.coords.longitude;
        gpsInc++;

        if (gpsInc == 10) {
            gpsAvgs.lat /= 10;
            gpsAvgs.long /= 10;
            console.log("User Location Average:", gpsAvgs.lat, ",", gpsAvgs.long);
            userOffset = convert(gpsAvgs.lat, gpsAvgs.long, 0);
            console.debug("userOffset set to", userOffset);
        }

        // console.log("Lat:", position.coords.latitude, "Long:", position.coords.longitude);
        // // Set camera to cartesian location
        // var loc = convert(position.coords.latitude, position.coords.longitude, 0);
        // userOffset = loc;
        // console.debug("userOffset set to", loc);


        // TODO: get elevation

    }

    /* Converts latitude and longitude to cartesian coordinates in meters */
    function convert(lat, lon, el) {
        const EARTH_RADIUS = 6371000; //meters
        var r = EARTH_RADIUS + el;

        // convert to radians
        var lat = lat * Math.PI/180;
        var lon = lon * Math.PI/180;

        // Calculate cartesian coordinates
        let x = r * Math.cos(lat) * Math.cos(lon);
        let y = r * Math.cos(lat) * Math.sin(lon);
        let z = r * Math.sin(lat);

        return {x:x, y:y, z:z};
    }

    getLocation();




    // + ========================= +
    // |       Websocket           |
    // + ========================= +
    var host = location.origin.replace(/^http/, 'ws')
    var ws = new WebSocket(host);

    ws.onopen = function() {
        console.log("Connected to Websocket");
        sendToServer({type:"getModelLocations"}); // Get Models
    }

    ws.onerror = function(error) {
        console.log("Websocket Error:", error);
    }

    ws.onmessage = function(e) {
        let data = JSON.parse(e.data);
        switch (data.type) {
            case "modelLocations":
                console.log("Got Model Locations");
                modelLocations = data.locations;
                placeModels();
                break;
            default:
                console.log("Got Unknow Type", data.type, data);
                break;
        }
    }

    function sendToServer(message) {
        if (typeof(message) === "string") {
            ws.send(message);
        }
        else if (typeof(message) === "object") {
            ws.send(JSON.stringify(message));
        }
    }


    function repositionCameraAt(x, y, z) {
        return;
    }

    function moveCameraBy(x, y, z) {
        userOffset.x += x;
        userOffset.y += y;
        userOffset.z += z;

        for (let i in scene.children) {
            scene.children[i].position.x -= x;
            scene.children[i].position.y -= y;
            scene.children[i].position.z -= z;
        }
    }

    function changePosition(axis) {
        var sensitivity = document.getElementById("sensitivity").value;
        console.debug("moving", document.getElementById("posSlider"+axis).value, "along", axis);
        moveCameraBy(
            document.getElementById("posSliderX").value * sensitivity,
            document.getElementById("posSliderY").value * sensitivity,
            document.getElementById("posSliderZ").value * sensitivity );
        document.getElementById("posSlider"+axis).value = 0;
    }

    function removeBlueLines() {
        for (let i in scene.children) {
            if (scene.children[i].type === "Line") {
                scene.remove(scene.children[i]);
            }
        }
    }
    </script>
</body>
</html>
